input {
  http {
    port => 8183
    # port => "${LOGSTASH_PORT:8181}"
    # type => "syslog"
    # type => "winlog"
    codec => json {

    }

  }
  stdin{
    type => "winlog"
  }
}
# 
# 
  # 
filter {
  if [log_type] == "WinEventLog" {
    mutate {
      copy => {
        "@timestamp" => "event.created"
      }
      remove_field => ["@timestamp","host","headers"]
      add_field => { 
          "[host]" => "%{computername}"
          "[event][code]" => "%{eventcode}"
          "[event][type]" => "%{eventtype}"
          "[winlog.keywords]" => "%{keywords}"
          "[log_name]" => "%{logname}"
          "[winlog.opcode]" => "%{opcode}"
          "[record_number]" => "%{recordnumber}"
          "[source][name]" => "%{sourcename}"
          "[task][category]" => "%{taskcategory}"
          "[log][type]" => "%{type}"
          }
    }
    if [sid]{
      mutate {
        add_field => {
          "[winlog.sid]" => "%{sid}"
          "[winlog.sid.type]" => "%{sidtype}"
        }
      }
    }
    if [error_code]{
      mutate {
        add_field => {
           "[error][code]" => "%{error_code}"
        }
      }
    }
  # Step 1: Extract the event code
    grok {
      match => {
        "raw_message" => "%{DATE:date} %{TIME:time} %{WORD:amorpm}%{GREEDYDATA}"
      }
    }
    
    ruby {
        init => "require 'time'"
          code => "
          date = event.get('date')
          time = event.get('time')
          amorpm = event.get('amorpm')
          datetime_string = date+time+amorpm
          puts datetime_string
          parsed_time = Time.strptime(datetime_string, '%m/%d/%Y%I:%M:%S%p')
          iso8601_format = parsed_time.iso8601
          event.set('timestamp',iso8601_format)
          "
        }
    # # Step 2: Conditional parsing based on the event code
    if [event][code] == "4648" {
      grok {
        match => {
          "message" => ["%{GREEDYDATA:winlog.message}\r\nSubject:\r\n\tSecurity ID:\t\t%{NOTSPACE}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.account.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.account.domain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.logon.id}\r\n\tLogon GUID:\t\t%{GREEDYDATA:winlog.logon.guid}\r\nAccount Whose Credentials Were Used:\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.destination.user.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.destination.domain}\r\n\tLogon GUID:\t\t%{NOTSPACE:winlog.destination.logon.guid}\r\nTarget Server:\r\n\tTarget Server Name:\t%{GREEDYDATA:winlog.destination.host.name}\r\n\tAdditional Information:\t%{GREEDYDATA:additional_info}\r\nProcess Information:\r\n\tProcess ID:\t\t%{DATA:process.pid}\r\n\tProcess Name:\t\t%{GREEDYDATA:process.name}\r\nNetwork Information:\r\n\tNetwork Address:\t%{GREEDYDATA:winlog.network.address}\r\n\tPort:\t\t\t%{DATA:winlog.network.port}\r\n%{GREEDYDATA:extra_info}","%{GREEDYDATA:log_message}\r\nSubject:\r\n\tSecurity ID:\t\t%{NOTSPACE:user.id}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.user.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.user.domain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.logon.id}\r\n\tLogon GUID:\t\t%{GREEDYDATA:winlog.logon.guid}\r\nAccount Whose Credentials Were Used:\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.destination.user.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.destination.domain}\r\n\tLogon GUID:\t\t%{NOTSPACE:winlog.destination.logon.guid}\r\nTarget Server:\r\n\tTarget Server Name:\t%{GREEDYDATA:winlog.destination.host.name}\r\n\tAdditional Information:\t%{GREEDYDATA:additional_info}\r\nProcess Information:\r\n\tProcess ID:\t\t%{DATA:process.pid}\r\n\tProcess Name:\t\t%{GREEDYDATA:process.name}\r\nNetwork Information:\r\n\tNetwork Address:\t%{GREEDYDATA:winlog.network.address}\r\n\tPort:\t\t\t%{DATA:winlog.network.port}"]
        }
      }
    } else if [event][code] in ["6013", "6005", "3", "82224", "1100", "1101", "1104", "1108", "4609"] {
      grok {
        match => {
          "message" => "%{GREEDYDATA:log_message}"
        }
      }
    } else if [event][code] == "1102" {
      grok {
        match => {
          "message" => "%{GREEDYDATA:winlog.message}\r\nSubject:\r\nSecurity ID:\t\t%{NOTSPACE:winlog.sid}\r\nAccount Name:\t\t%{GREEDYDATA:winlog.user.name}\r\n\tDomain Name:\t\t%{GREEDYDATA:winlog.user.domain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.logon.id}"
        }
      }
    } else if [event][code] == "4608" {
      grok {
        match => {
          "message" => "%{GREEDYDATA:winlog.message}\r\n%{GREEDYDATA:extra_info}"
        }
      }
    } else if [event][code] == "4798"{
      grok {
        match => {
          "message" => "A user's local group membership was enumerated.\r\n\r\nSubject:\r\n\tSecurity ID:\t\t%{NOTSPACE}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.user.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.user.domain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.logon.id}\r\n\r\nUser:\r\n\tSecurity ID:\t\t%{NOTSPACE:winlog.user.sid}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.user.accountname}\r\n\tAccount Domain:\t\t%{NOTSPACE:winlog.user.accountdomain}\r\n\r\nProcess Information:\r\n\tProcess ID:\t\t%{NOTSPACE:winlog.process.id}\r\n\tProcess Name:\t\t%{NOTSPACE:winlog.process.name}"
        }
      }
    } else if [event][code] == "4672"{
      grok {
        match => {
          "message" => "Special privileges assigned to new logon.\r\n\r\nSubject:\r\n\tSecurity ID:\t\t%{NOTSPACE}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.account.name}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.account.domain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.logon.id}\r\n\r\nPrivileges:\t\tSeAssignPrimaryTokenPrivilege\r\n\t\t\tSeTcbPrivilege\r\n\t\t\tSeSecurityPrivilege\r\n\t\t\tSeTakeOwnershipPrivilege\r\n\t\t\tSeLoadDriverPrivilege\r\n\t\t\tSeBackupPrivilege\r\n\t\t\tSeRestorePrivilege\r\n\t\t\tSeDebugPrivilege\r\n\t\t\tSeAuditPrivilege\r\n\t\t\tSeSystemEnvironmentPrivilege\r\n\t\t\tSeImpersonatePrivilege\r\n\t\t\tSeDelegateSessionUserImpersonatePrivilege"
        }
      }
    } else if [event][code] == "4624"{
      grok {
        match => {

          "message" => "An account was successfully logged on.\r\n\r\nSubject:\r\n\tSecurity ID:\t\t%{NOTSPACE:winlog.subject.sid}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.subject.accountname}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.subject.accountdomain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.subject.logonid}\r\n\r\nLogon Information:\r\n\tLogon Type:\t\t%{NUMBER:winlog.logontype}\r\n\tRestricted Admin Mode:\t%{DATA:winlog.restrictedadminmode}\r\n\tRemote Credential Guard:\t%{DATA:winlog.remotecredentialguard}\r\n\tVirtual Account:\t\t%{GREEDYDATA:winlog.virtualaccount}\r\n\tElevated Token:\t\t%{WORD:winlog.elevatedtoken}\r\n\r\nImpersonation Level:\t\t%{GREEDYDATA:winlog.impersonationlevel}\r\n\r\nNew Logon:\r\n\tSecurity ID:\t\t%{NOTSPACE:winlog.newlogon.sid}\r\n\tAccount Name:\t\t%{GREEDYDATA:winlog.newlogon.accountname}\r\n\tAccount Domain:\t\t%{GREEDYDATA:winlog.newlogon.accountdomain}\r\n\tLogon ID:\t\t%{NOTSPACE:winlog.newlogon.logonid}\r\n\tLinked Logon ID:\t\t%{NOTSPACE:winlog.newlogon.linkedlogonid}\r\n\tNetwork Account Name:\t%{DATA:winlog.newlogon.networkaccountname}\r\n\tNetwork Account Domain:\t%{DATA:winlog.newlogon.networkaccountdomain}\r\n\tLogon GUID:\t\t%{NOTSPACE:winlog.newlogon.logonguid}\r\n\r\nProcess Information:\r\n\tProcess ID:\t\t%{NOTSPACE:winlog.process.id}\r\n\tProcess Name:\t\t%{NOTSPACE:winlog.process.name}\r\n\r\nNetwork Information:\r\n\tWorkstation Name:\t%{DATA:winlog.networkinformation.workstationname}\r\n\tSource Network Address:\t%{DATA:winlog.networkinformation.sourcenetworkaddress}\r\n\tSource Port:\t\t%{DATA:winlog.networkinformation.sourceport}\r\n\r\nDetailed Authentication Information:\r\n\tLogon Process:\t\t%{WORD:winlog.authinfo.logonprocess}  \r\n\tAuthentication Package:\t%{GREEDYDATA:winlog.authinfo.authenticationpackage}\r\n\tTransited Services:\t%{DATA:winlog.authinfo.transitedservices}\r\n\tPackage Name \(NTLM only\):\t%{DATA:winlog.authinfo.packagename}\r\n\tKey Length:\t\t%{NUMBER:winlog.authinfo.keylength}%{GREEDYDATA:winlog.eventinfo}
"

        }
      }
    }

    # Add more conditions for other event codes as needed

    # Optionally, you can remove the 'rest_of_message' field after parsing

    date {
      # 2024-07-05T18:48:21+05:00
        match => ["timestamp", "ISO8601"]
        target => "@timestamp"
        locale => "en"
      }
    mutate {
      remove_field => ["date","time","amorpm","timestamp","computername","sourcename","opcode","recordnumber","taskcategory","error_code","eventtype","eventcode","logname","user","keywords","sid","sidtype","type"]

    }


  }
  if [log_type] == "syslog" or [type] == "syslog"{
    mutate {
      copy => { "@timestamp" => "event.created" }
      # copy => { "host" => "host.hostname" }
      remove_field => ["@timestamp","host"]
    }
    grok {
    match => { "message" => "%{SYSLOGTIMESTAMP} %{GREEDYDATA}" }
    # Optional: Tag event with "_grokparsefailure" if no match
    tag_on_failure => ["no_time_stamp"]
  }
    grok {
      match => { 
        "message" => [
      # Jul 23 16:37:44 192.168.1.236 Jul 23 16:37:44 splunk systemd[1]: plymouth-quit.service: Deactivated successfully.
         
          "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:host} %{SYSLOGTIMESTAMP} %{DATA:hostname} %{DATA:process.name}\[%{NUMBER:process.pid}\]: %{GREEDYDATA:log_message}",
          "%{SYSLOGTIMESTAMP:timestamp} %{IP:ip1} %{SYSLOGTIMESTAMP:timestamp2} %{DATA:hostname} %{WORD:process.name}: %{USER:user} : TTY=%{NOTSPACE:tty} ; PWD=%{PATH:pwd} ; USER=%{USER:sudo_user} ; COMMAND=%{GREEDYDATA:command}",
          "%{SYSLOGTIMESTAMP:timestamp} %{WORD:program} \(%{WORD:process.name}\): %{GREEDYDATA:log_message}",
          "%{GREEDYDATA:log_message}"
        ]
      }
    }

    if [log_message] {
      grok {
        match => {
          "log_message" => [
            "PAM %{NUMBER:failures_count} more authentication failures; logname=%{DATA:logname} uid=%{NUMBER:uid} euid=%{NUMBER:euid} tty=%{WORD:tty} ruser=%{DATA:ruser} rhost=%{IP:source_ip}  user=%{WORD:user}",
            "pam_unix\(%{WORD:service}:session\): session opened for user %{USER:user}\(uid=%{NUMBER:uid}\) by \(uid=%{NUMBER:by_uid}\)",
            "pam_unix\(%{WORD:service}:session\): session opened for user %{USER:user}\(uid=%{NUMBER:uid}\) by %{USER}\(uid=%{NUMBER:by_uid}\)",
            "pam_unix\(%{WORD:service}:session\): session closed for user %{USER:user}",
            "pam_unix\(%{WORD:service}:auth\): authentication failure; logname=%{DATA:logname} uid=%{NUMBER:uid} euid=%{NUMBER:euid} tty=%{WORD:tty} ruser= rhost=%{IP:source_ip}  user=%{USER:user}",
            "Failed password for %{USER:username} from %{IP:source.ip} port %{NUMBER:destination.port} %{WORD:ssh.protocol}",
            "Accepted password for %{USER:username} from %{IP:source.ip} port %{NUMBER:destination.port} %{WORD:ssh.protocol}",
            "rsyslogd: cannot connect to %{IP:destination.ip}:%{NUMBER:destination.port}: Connection refused \[%{NOTSPACE:event.version} try %{URI:url.original} \]",
            "PAM service\(%{WORD:service}\) ignoring max retries; %{NUMBER:retry_count} > %{NUMBER:max_retries}",
            "New session %{DATA:session.id} of user %{USER:username}.",
            # Connection closed by 192.168.1.42 port 39942 [preauth]
            "Connection closed by %{IP:source.ip} port %{NUMBER:destination.port} \[preauth\]",
            # Unable to negotiate with 192.168.1.42 port 39924: no matching host key type found. Their offer: ecdsa-sha2-nistp384 [preauth]
            "Unable to negotiate with %{IP:source.ip} port %{NUMBER:destination.port}: no matching host key type found. Their offer: %{DATA:hash_protocol} \[preauth\]",
            "%{SYSLOGTIMESTAMP:timestamp} %{IP:ip1} %{SYSLOGTIMESTAMP:timestamp2} %{SYSLOGHOST:hostname} %{WORD:process}\[%{NUMBER:pid}\]: pam_unix\(%{WORD:service}:session\): session opened for user %{USER:user}\(uid=%{NUMBER:uid}\) by \(uid=%{NUMBER:by_uid}\)",
            "\(%{USER:user}\) %{CRON_ACTION:[system][cron][action]} \(%{DATA:[system][cron][command]}\)",
            "%{WORD:status} password for %{USER:user} from %{IP:source.ip} port %{NUMBER:destination.port} %{WORD:protocol}",
            "%{TIME:time} %{LOGLEVEL:loglevel}  %{DATA:component} - \(#%{NUMBER:attempt}\) %{GREEDYDATA:message_body}",
            "%{LOGLEVEL:loglevel}: %{WORD:failures_count} authentication attempts exceeded for %{USER:user} from %{IP:source.ip} port %{NUMBER:destination.port} %{WORD:ssh.protocol} \[%{WORD:process.args}\]",
            "%{GREEDYDATA}"
            ]
        }
      }
    }
    mutate {
    lowercase => ["log_message"]
  }

  if "authentication failure" in [log_message] or "failed password" in [log_message] or "authentication attempts exceeded" in [log_message]{
     mutate {
        add_field => { 
          "[event][type]" => ["access","denied"]
          "[event][action]" =>"user_login"
          "[event][category]"=>["authentication"]
          "[event][outcome]"=>"failure"
          }
    }
  }
  else if "authentication success" in [log_message] or "accepted password" in [log_message] {
   mutate {
        add_field => { 
          "[event][type]" => ["access","allowed"]
          "[event][category]"=>["authentication"]
          "[event][outcome]"=>"success"
          "[event][action]" =>"user_login"
        }
    }
  }
  else if "ignoring max retries" in [log_message] {
   mutate {
        add_field => { 
          "[event][action]" => "authentication_configuration_change"
          "[event][category]"=>["authentication"]
          "[event][type]"=>["change"]
        }
    }
  }
    mutate {
      remove_field => [
        "headers"
      # ,"message"
      ]
    }
  if "connection refused" in [log_message] {
    mutate {
        add_field => { 
          "[event][type]" => ["denied"]
          "[event][category]"=>["network","connection"]
        }
  }}
  if "connection recieved" in [log_message] {
    mutate {
        add_field => { 
          "[event][action]" => "connection_recieved"
          "[event][category]"=>["network","connection"]
        }
  }}

  if "new session" in [log_message] or "session opened" in [log_message] {
    mutate {
        add_field => { 
          "[event][type]" => ["creation"]
          "[event][category]"=>["session"]
        }
  }}
  if "connection closed by" in [log_message] or "no matching host key type found" in [log_message] {
    mutate {
        add_field => { 
          "[event][type]" => ["start"]
          "[event][category]"=>["network"]
          "[event][action]"=>"connection_attempted"
        }
  }}
  if "no_time_stamp" in [tags] {
      mutate{
        copy => {
          "event.created" => "@timestamp"
        }
      }
      
  }
  if "encrypt" in [log_message] or "decrypt" in [log_message] or "coin" in [log_message] or "crypto" in [log_message]{
    mutate {
        add_field => { 
          "[event][type]" => ["indicator"]
          "[event][category]"=>["threat","intrusion_detection","vulnerability","malware"]
          "[event][action]" => "ransom"
        }
   
  }}
    date {
      match => ["timestamp", "MMM dd HH:mm:ss","MMM  d HH:mm:ss"]
      target => "@timestamp"
      locale => "en"
    }
  mutate {
      remove_field => ["timestamp"]
    }
}
}
output {  
  # elasticsearch {
  #       hosts => "http://192.168.1.103:9200"
  #       # hosts=> "${ELASTIC_HOST:127.0.0.1:9200}"
  #       index => "%{index}"
  # }
  stdout{}
}

#Jul 23 13:23:00 192.168.1.30 Jul 23 18:23:00 ubuntu16 sudo: vboxuser : TTY=pts/26 ; PWD=/home/vboxuser ; USER=root ; COMMAND=/usr/bin/apt purge python3-pip
#%{SYSLOGTIMESTAMP:timestamp1} %{IP:ip1} %{SYSLOGTIMESTAMP:timestamp2} %{SYSLOGHOST:hostname} %{WORD:process}: %{WORD:auth_type}\(%{WORD:auth_mechanism}\): session %{WORD:session_state} for user %{USER:user} by %{USER:by_user}\(uid=%{NUMBER:uid}\)
  # "substring1" in [message] or "substring2" in [message]
   # "%{SYSLOGTIMESTAMP:timestamp} %{IP:host} %{SYSLOGTIMESTAMP} %{SYSLOGHOST:log_source} %{WORD:process}\[%{NUMBER:pid}\]: %{TIME:time} %{LOGLEVEL:loglevel}  %{DATA:component} - \(#%{NUMBER:attempt}\) %{GREEDYDATA:message_body}",
          # "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:host} %{SYSLOGTIMESTAMP:t2}%{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}",
# Jul 23 12:30:45 192.168.1.30 Jul 23 17:30:45 ubuntu16 sshd[13723]: PAM 4 more authentication failures; logname= uid=0 euid=0 tty=ssh ruser=someuser rhost=192.168.1.39  user=vboxuser
